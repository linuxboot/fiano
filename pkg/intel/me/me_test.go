// Copyright 2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package me

import (
	"bytes"
	"errors"
	"fmt"
	"testing"
)

var (
	validLegacyHeaderPadding = []byte{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}
	validME = []byte{
		0x24, 0x46, 0x50, 0x54, 0x02, 0x00, 0x00, 0x00,
		0x20, 0x01, 0x20, 0x30, 0x00, 0x01, 0x01, 0x01,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// first entry
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// second entry
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}
	invalidMEEntryNumber = []byte{
		0x24, 0x46, 0x50, 0x54, 0x07, 0x00, 0x00, 0x00,
		0x20, 0x01, 0x20, 0x30, 0x00, 0x01, 0x01, 0x01,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// first entry
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// second entry
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}
)

func TestParseIntelME(t *testing.T) {
	for _, tt := range []struct {
		name    string
		data    []byte
		wantErr error
	}{
		{
			name: "Test Lagacy ME",
			data: append(validLegacyHeaderPadding, validME...),
		},
		{
			name: "Test ME",
			data: validME,
		},
		{
			name:    "Invalid Entry number",
			data:    invalidMEEntryNumber,
			wantErr: errors.New("EOF"),
		},
	} {
		t.Run(tt.name, func(t *testing.T) {
			_, gotErr := ParseIntelME(bytes.NewReader(tt.data))
			if gotErrorString, wantErrorString := fmt.Sprint(gotErr), fmt.Sprint(tt.wantErr); gotErrorString != wantErrorString {
				t.Errorf("ParseIntelME() got err %q; want err %q",
					gotErrorString,
					wantErrorString)
			}
		})
	}
}
